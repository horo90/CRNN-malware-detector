import os
import operator
import numpy as np

class Extractor:
    def __init__(self, fpath):
        self.fpath = fpath

    def indexing_instruction(self, top_inst):
        opcodes = self.read_file()
        indexed_opcodes = list()
        for opcode in opcodes:
            indexed_opcodes.append(top_inst[opcode] if top_inst.get(opcode) is not None else top_inst['etc'])
        return indexed_opcodes

    def read_file(self):
        f = open(self.fpath, 'r')
        opcodes = list()
        while True:
            line = f.readline()

            if line is None or line == '':break
            else:
                code = line.replace('\n', '')
                if len(code) > 0:
                    opcode = code.split('\t')[1].split(' ')[0]
                    opcodes.append(opcode)
        f.close()
        return opcodes

def read_file(fpath):
    f = open(fpath, 'r')
    opcodes = list()
    while True:
        line = f.readline()
        if line is None or line == '':break
        else:
            line = line.replace('\n', '')
            if len(line) > 0:
                opcode = line.split('\t')[1].split(' ')[0]
                opcodes.append(opcode)
    f.close()
    return opcodes

def make_top_inst(root, n_top=30):
    opcode_dict = dict()
    types = os.listdir(root)
    for type in types:
        if type == 'normal':
            path = os.path.join(root, type)
            bins = os.listdir(path)

            for bin in bins:
                bpath = os.path.join(path, bin)
                files = os.listdir(bpath)

                for file in files:
                    fpath = os.path.join(bpath, file)
                    opcodes = read_file(fpath)

                    for opcode in opcodes:
                        if opcode not in opcode_dict:
                            opcode_dict[opcode] = 0
                        cnt = opcode_dict[opcode] + 1
                        opcode_dict[opcode] = cnt
    sorted_dict = sorted(opcode_dict.items(), key=operator.itemgetter(1), reverse=True)
    top_inst = list()
    for i in range(n_top):
        top_inst.append(sorted_dict[i][0])
    top_inst.append('etc')

    f = open('./top_inst.txt', 'w')
    for i in range(len(top_inst)):
        f.write(top_inst[i] + '\t' + str(i+1) + '\n')
    f.close()

def read_top_inst():
    f = open('./top_inst.txt', 'r')
    top_inst = dict()
    while True:
        line = f.readline()
        if line is None or line == '' : break
        else:
            item = line.replace('\n', '').split('\t')
            top_inst[item[0]] = item[1]
    f.close()
    return top_inst


def run(root, save_dir, strategy):
    root = root + '_' + strategy
    save_dir = save_dir + '_' + strategy

    print('[*] create top_inst.txt')
    if not os.path.exists('./top_inst.txt'):
        make_top_inst(root, n_top=47)
    top_inst = read_top_inst()
    types = os.listdir(root)

    if not os.path.exists(save_dir):
        os.mkdir(save_dir)

    for type in types:
        type_indexed_paths = list()

        if not os.path.exists(os.path.join(save_dir, type)):
            os.mkdir(os.path.join(save_dir, type))

        path = os.path.join(root, type)
        bins = os.listdir(path)

        print('[*]', type, 'indexing...')
        for bin in bins:

            bpath = os.path.join(path, bin)
            files = os.listdir(bpath)

            for file in files:
                fpath = os.path.join(bpath, file)
                print(fpath)
                ext = Extractor(fpath)
                indexed_instruction = ext.indexing_instruction(top_inst)
                type_indexed_paths.append(indexed_instruction)
        print('[*] saving...')
        type_indexed_paths = np.array(type_indexed_paths)
        np.save(os.path.join(os.path.join(save_dir, type), 'data'), type_indexed_paths)
