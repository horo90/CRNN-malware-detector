from capstone import *
import pefile
import numpy as np
import copy
import os
import time
import utils

class Instruction:
    def __init__(self, addr, opcode, operand, bytes, size):
        self.addr = addr
        self.opcode = opcode
        self.operand = operand
        self.bytes = bytes
        self.size = size
        self.visited = False

    def __str__(self):
        return hex(self.addr) + '\t' + self.opcode + '\t' + self.operand

class PathFiner:
    def __init__(self, path, fn):
        self.fn = fn
        self.pe = pefile.PE(path, fast_load=True)

        if self.pe.OPTIONAL_HEADER.Magic == 0x20b:
            print(fn)
            raise pefile.PEFormatError('x64 binary')

        self.neg_history = list()
        self.ep = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.imageBase = self.pe.OPTIONAL_HEADER.ImageBase
        self.md = Cs(CS_ARCH_X86, CS_MODE_32)
        self.data = self.pe.get_memory_mapped_image()
        self.offset = 100
        self.importTable = list()
        self.pe.full_load()

        self.main_func_patterns = [
            ['push r', 'push i', 'push r', 'push r', 'call', 'push r', 'call'],
            ['push r', 'push r', 'push r', 'push r', 'call', 'push r', 'call'],
            ['push r', 'push r', 'push n', 'push n', 'call', 'push r', 'call'],
            ['push r', 'push r', 'push n', 'push n', 'call'],
            ['push r', 'push r', 'push r', 'push n', 'call'],
            ['push i', 'push i', 'push i', 'call'],
            ['push r', 'push r', 'push i', 'call']
        ]

        self.exit_proc_funcs = [
            'abort', 'exitprocess', 'exit', 'thunrtmain', 'afxwinmain', 'terminateprocess'
        ]
        self.not_exit_proc_funcs = [
            'msg', 'exitwindow'
        ]

        self.pe.parse_data_directories()
        try:
            for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    self.importTable.append((imp.address, imp.name))
        except:
            print('[*] no IMP')

    def init(self):
        self.instructions = list()

    def _find_index(self, a, b):
        len_b = len(b)
        for pos in range(len(a) - len_b + 1):
            if a[pos : pos + len_b] == b:
                return pos
        return -1

    def find_main_func(self, start):
        chunk = self.data[start : start + 1000]
        gen = self.md.disasm(chunk, start + self.imageBase)
        first_inst = next(gen)
        second_inst = next(gen)

        if first_inst.mnemonic == 'call' and second_inst.mnemonic == 'jmp':
            start = int(second_inst.op_str, 0) - self.imageBase

        chunk = self.data[start: start + 1000]
        addresses = list()
        mnems = list()
        operands = list()
        for inst in self.md.disasm(chunk, start + self.imageBase):
            addresses.append(inst.address)
            op = inst.mnemonic.encode('ascii', 'ignore')
            if inst.mnemonic == 'push':
                if '[' in inst.op_str: op += ' i'
                else:
                    try:
                        tmp = int(inst.op_str, 0)
                        op += ' n'
                    except:
                        op += ' r'
            mnems.append(op)
            operands.append(inst.op_str)
        p_ind = -1
        which_pattern = -1
        for i in range(len(self.main_func_patterns)):
            p_ind = self._find_index(mnems, self.main_func_patterns[i])
            if p_ind > -1:
                which_pattern = i
                break

        if p_ind > -1 and which_pattern > -1:
            rindex =  mnems[p_ind : p_ind + len(self.main_func_patterns[which_pattern])][::-1].index('call')
            sub_ind = len(self.main_func_patterns[which_pattern]) - rindex -1
            main_func = addresses[p_ind + sub_ind] - self.imageBase
            chunk = self.data[main_func : main_func + 50]
            if '[' not in operands[p_ind + sub_ind]:
                try:
                    ptr = int(operands[p_ind + sub_ind], 0) - self.imageBase
                    return ptr
                except:
                    print('??')
                    return start
            else:
                return start
        else: return start


    def transfer_call(self, instruction, return_stack, cur_addr):
        if '[' not in instruction.operand:
            try:
                # check exit first
                jmp_loc = int(instruction.operand, 0) - self.imageBase
                codes = self.data[jmp_loc : jmp_loc + self.offset]
                inst = next(self.md.disasm(codes, jmp_loc + self.imageBase))
                if 'jmp' in inst.mnemonic and '[' in inst.op_str:
                    try:
                        dst = int(inst.op_str.split('[')[1].split(']')[0], 0)
                        if self.isExitProcess(dst):
                            cur_addr = -1
                            return cur_addr
                        else:
                            return_stack.append(instruction.addr + instruction.size)
                            return -2
                    except:
                        pass
                else:
                    return_stack.append(instruction.addr + instruction.size)
                    cur_addr = int(instruction.operand, 0) - self.imageBase
            except:
                cur_addr = instruction.addr + instruction.size - self.imageBase
        else:
            ptr = instruction.operand.split('[')[1].split(']')[0]
            try:
                ptr = int(ptr, 0)
                if self.isExitProcess(ptr):
                    cur_addr = -1
            except:
                pass
        return cur_addr


    def transfer_ret(self, instruction, return_stack):
        if not return_stack: return -2

        cur_addr = return_stack.pop() - self.imageBase
        return cur_addr

    def _check_in_IMT(self, addr):
        for (a, f) in self.importTable:
            if a == addr:
                return True
        return False

    def transfer_jmp(self, instruction, cur_addr):
        if '[' not in instruction.operand:
            try:
                cur_addr = int(instruction.operand, 0) - self.imageBase
            except:
                cur_addr = instruction.addr + instruction.size - self.imageBase
        else:
            ptr = instruction.operand.split('[')[1].split(']')[0]
            try:
                ptr = int(ptr, 0)
                if self.isExitProcess(ptr):
                    cur_addr = -1
                elif self._check_in_IMT(ptr):
                    cur_addr = -2
            except:
                pass
        return cur_addr

    def transfer_cjmp(self, instruction, guid_direction, branch_addresses, branch_directions, loop_flag):
        branch = list()
        branch.append(int(instruction.operand, 0))
        branch.append(instruction.addr + instruction.size)

        if len(guid_direction) > 0:
            r = guid_direction.pop(0)
            cur_addr = branch[r] - self.imageBase
            branch_directions.append(r)
            branch_addresses.append(cur_addr)
            return cur_addr
        else:
            if not loop_flag:
                r = np.random.randint(0, 2)
                cur_addr = branch[r]
                if self.search_instruction(cur_addr) is not None:
                    r = np.abs(r - 1)
                cur_addr = branch[r]
                if self.search_instruction(cur_addr) is not None:
                    r = np.abs(r - 1)
                cur_addr = branch[r] - self.imageBase
                branch_directions.append(r)
                branch_addresses.append(cur_addr)
            else:
                tmp = copy.deepcopy(branch_addresses)
                tmp.reverse()
                r = -1
                for addr in tmp:
                    if (addr + self.imageBase) in branch:
                        for i in range(len(branch)):
                            if (addr + self.imageBase) == branch[i]:
                                r = i
                                break
                        break
                if r == -1:
                    r = np.random.randint(0, 2)
                else:
                    r = np.abs(r - 1)
                cur_addr = branch[r] - self.imageBase
            return cur_addr

    def search_instruction(self, addr):
        tmp = None
        for i in self.instructions:
            if i.addr == addr:
                tmp = i
        return tmp

    def check_loop(self, inst, prev_inst):
        if self.search_instruction(inst.addr) is not None \
                and inst.addr < prev_inst.addr \
                and prev_inst is not None and prev_inst.opcode != 'call':
            return True
        else: return False

    def isExitProcess(self, addr):
        for (a, f) in self.importTable:
            if f is not None:
                f = f.lower()
                if addr == a \
                        and any(s in f for s in self.exit_proc_funcs) \
                        and not any(s in f for s in self.not_exit_proc_funcs):
                    print(f)
                    return True
        return False

    def load_info(self, order, strategy):
        if order == 0: return None, None
        else:
            lens = list()
            for i in range(order):
                tmp = np.load('./branch-history_' + strategy + '/'+self.fn+'/data' + str(i) + '.npy').tolist()
                lens.append(len(tmp))
            max_ind = np.argmax(np.array(lens))

            return np.load('./branch-history_' + strategy + '/'+self.fn+'/data' + str(max_ind) + '.npy').tolist(), max_ind

    def save_info(self, branch_directions, branch_addresses, strategy, order):
        if not os.path.exists('./branch-history_' + strategy):
            os.mkdir('./branch-history_' + strategy)
        if not os.path.exists('./branch-address_' + strategy):
            os.mkdir('./branch-address_' + strategy)

        if not os.path.exists('./branch-history_' + strategy + '/' + self.fn):
            os.mkdir('./branch-history_' + strategy + '/' + self.fn)
        if not os.path.exists('./branch-address_' + strategy + '/' + self.fn):
            os.mkdir('./branch-address_' + strategy + '/' + self.fn)

        np.save('./branch-history_' + strategy + '/'+self.fn+'/data' + str(order), np.array(branch_directions))
        np.save('./branch-address_' + strategy + '/'+self.fn+'/data' + str(order), np.array(branch_addresses))

    def create_guide_branch(self, branch_directions, longest_branch_ind, strategy):
        r = None
        if strategy == 'random':
            i = 0
            while True:
                r = np.random.randint(0, len(branch_directions))
                if (longest_branch_ind, r) not in self.neg_history or i == 5:break
                else:
                    i += 1
            self.neg_history.append((longest_branch_ind, r))
        elif strategy == 'prob_f':
            ind = np.arange(len(branch_directions))
            p = utils.arithmetic_prob(ind)[::-1]
            tmp = list()
            while True:
                r = np.random.choice(ind, 1, p=p)[0]
                tmp.append((longest_branch_ind, r))
                if (longest_branch_ind, r) not in self.neg_history:break
                else:
                    if len(ind) == 1:
                        longest_branch_ind, r = tmp[0]
                        break
                    ind = ind.tolist()
                    ind.pop(ind.index(r))
                    ind = np.array(ind)
                    p = utils.arithmetic_prob(ind)[::-1]
            self.neg_history.append((longest_branch_ind, r))
        elif strategy == 'prob_b':
            ind = np.arange(len(branch_directions))
            p = utils.arithmetic_prob(ind)
            tmp = list()
            while True:
                r = np.random.choice(ind, 1, p=p)[0]
                tmp.append((longest_branch_ind, r))
                if (longest_branch_ind, r) not in self.neg_history: break
                else:
                    if len(ind) == 1:
                        longest_branch_ind, r = tmp[0]
                        break
                    ind = ind.tolist()
                    ind.pop(ind.index(r))
                    ind = np.array(ind)
                    p = utils.arithmetic_prob(ind)
            self.neg_history.append((longest_branch_ind, r))

        branch_directions = branch_directions[:r + 1]
        branch_directions[r] = np.abs(branch_directions[r] - 1)
        return branch_directions

    def _check_null_or_cc_bytes(self, codes):
        if '\x00\x00\x00\x00\x00\x00\x00\x00' in codes:
            ind = codes.index('\x00\x00\x00\x00\x00\x00\x00\x00')
            return codes[:ind]
        elif '\xcc\xcc\xcc\xcc\xcc' in codes:
            ind = codes.index('\xcc\xcc\xcc\xcc\xcc')
            return codes[:ind]
        else: return codes

    def extractPath(self, order, save_path, timeout, strategy):
        cur_addr = self.find_main_func(self.ep)
        # print hex(cur_addr + self.imageBase)
        return_stack = list()
        branch_directions = list()
        branch_addresses = list()
        guid_direction = list()

        if strategy == 'noguided':
            prev_branch_directions = list()
            copy_guide_direction = list()
        elif strategy in ['random', 'prob_f', 'prob_b']:
            prev_branch_directions, longest_branch_ind = self.load_info(order, strategy)
            if prev_branch_directions is not None and len(prev_branch_directions) > 0:
                guid_direction = self.create_guide_branch(prev_branch_directions, longest_branch_ind, strategy)
            copy_guide_direction = copy.deepcopy(guid_direction)

        f = open(save_path + '/' + str(order) + '.txt', 'w')

        round = 0
        no_more_return = False
        prev_inst = None
        loop_flag = False

        start_time = time.time()
        end_time = 0
        while True:
            if cur_addr == -1:
                print('\t[!] detected exitProcess or something like that!')
                break
            codes = self.data[cur_addr : cur_addr + self.offset]
            codes = self._check_null_or_cc_bytes(codes)
            if len(codes) == 0:break

            check_empty_gen = 0
            for inst in self.md.disasm(codes, cur_addr + self.imageBase):
                check_empty_gen += 1
                instruction = Instruction(inst.address, inst.mnemonic, inst.op_str, inst.bytes, inst.size)
                instruction.visited = True
                cur_addr = instruction.addr + instruction.size - self.imageBase
                f.write(str(instruction) + '\n')

                if self.check_loop(instruction, prev_inst) :
                    loop_flag = True

                self.instructions.append(instruction)

                if instruction.opcode == 'call':
                    cur_addr = self.transfer_call(instruction, return_stack, cur_addr)
                    if cur_addr == -2:
                        cur_addr = self.transfer_ret(instruction, return_stack)
                    break
                elif 'j' in instruction.opcode:
                    if 'jmp' in instruction.opcode:
                        cur_addr = self.transfer_jmp(instruction, cur_addr)
                        if cur_addr == -2:
                            cur_addr = self.transfer_ret(instruction, return_stack)
                            if cur_addr == -2:
                                no_more_return = True
                        break
                    else:
                        cur_addr = self.transfer_cjmp(instruction, guid_direction, branch_addresses, branch_directions, loop_flag)
                        if loop_flag:
                            loop_flag = False
                        break
                elif 'ret' in instruction.opcode:
                    if len(return_stack) == 0:
                        no_more_return = True
                        break
                    cur_addr = self.transfer_ret(instruction, return_stack)
                    if cur_addr == -2:
                        no_more_return = True
                        break
                    break
                elif 'hlt' == instruction.opcode:
                    no_more_return = True
                    break
            if check_empty_gen == 0:
                print('\t[!] blocked for some reason')
                break

            prev_inst = instruction

            if no_more_return:
                print('\t[!] no more return')
                break
            else:
                end_time = time.time()
                if end_time - start_time > timeout:
                    print('\t[!] timeout')
                    break

            round += 1

        f.close()
        print('\t[*] strategy : ', strategy)
        print('\t[*] return stack : ', return_stack)
        print('\t[*] prev branch: ', prev_branch_directions)
        print('\t[*] guid branch: ', copy_guide_direction)
        print('\t[*] branch dirs: ', branch_directions)
        print('\t[*] branch addr: ', branch_addresses)
        print('\t[*] length inst: ', len(self.instructions))
        print('\t[*] time: ', (end_time - start_time))

        self.save_info(branch_directions, branch_addresses, strategy, order)

        return self.instructions


def delete_not_pe():
    f = open('./no_pe.txt', 'r')
    while True:
        line = f.readline()
        if line is None or line == '' :break
        else:
            line = line.replace('\n', '')

            for (path, dir, files) in os.walk('./'):
                for fn in files:
                    if fn == line:
                        p = os.path.join(path, fn)
                        os.remove(p)
                        os.removedirs(path)
    f.close()

    f = open('./zero_len.txt', 'r')
    while True:
        line = f.readline()
        if line is None or line == '':
            break
        else:
            line = line.replace('\n', '')

            for (path, dir, files) in os.walk('./'):
                for fn in files:
                    if fn == line:
                        p = os.path.join(path, fn)
                        os.remove(p)
                        os.removedirs(path)
    f.close()


def run(root, save_path, n_extract_path, timeout, strategy, limit_len):
    if strategy is None or strategy not in ['noguided', 'random', 'prob_f', 'prob_b']:
        print('[!] Extraction strategy must be one of these.')
        print('\tnoguided : each extracted path is independent with each other')
        print('\trandom : do guided extraction, but negating branch randomly')
        print('\tprob_f: do guided extraction, give a large probability by branching swallow depth(arithmetic seq)')
        print('\tprob_b: do guided extraction, give a large probability by branching deep depth(arithmetic seq)')
        return

    if not os.path.exists(save_path + '_' + strategy):
        os.mkdir(save_path + '_' + strategy)

    types = os.listdir(root)
    types.sort()
    f = open('./no_pe.txt', 'w')
    f2 = open('./zero_len.txt', 'w')
    for t in types:
        if not os.path.exists(os.path.join(save_path + '_' + strategy, t)):
            os.mkdir(os.path.join(save_path + '_' + strategy, t))

        path = os.path.join(root, t)
        bins = os.listdir(path)
        bins.sort()
        k = 0
        for bin in bins:
            if not os.path.exists(os.path.join(os.path.join(save_path + '_' + strategy, t), bin)):
                os.mkdir(os.path.join(os.path.join(save_path + '_' + strategy, t), bin))
            else:continue

            bpath = os.path.join(path, bin)
            try:
                pf = PathFiner(bpath, bin)
                for i in range(n_extract_path):
                    print(t, bin, i)

                    pf.init()
                    insts = pf.extractPath(i, os.path.join(os.path.join(save_path + '_' + strategy, t), bin), timeout, strategy)
                    if len(insts) < limit_len:
                        f2.write(bin + '\n')
                k += 1
            except (pefile.PEFormatError, StopIteration) as e:
                f.write(bin + '\n')

    f2.close()
    f.close()
    utils.remove_non_pe(n_extract_path)